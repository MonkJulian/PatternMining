package naive;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

import patex.PatEx;
import fst.XFst;
import fst.Fst;
import fst.OutputLabel;
import hierarchy.SimpleHierarchy;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.objects.Object2LongOpenCustomHashMap;
import utils.Dictionary;
import utils.IntArrayStrategy;
import utils.PrimitiveUtils;
import writer.LogWriter;
import writer.SequentialWriter;

public class NaiveIterative {
	
	//TODO: changed separator in state/output parallel arrays!
	
	SimpleHierarchy hierarchy = SimpleHierarchy.getInstance();

	Object2LongOpenCustomHashMap<int[]> outputSequences = new Object2LongOpenCustomHashMap<int[]>(
			new IntArrayStrategy());

	int sigma;

	XFst dfa;

	boolean writeOutput = true;
	
	boolean useFlist = true;
	
	// Parallel arrays for yeilds and state
	OutputLabel[] yieldArray;
	int[] stateArray;

	int[] sequence;

	int sid = -1;
	
	int noOutputPatterns = 0;
	
	int[] flist = Dictionary.getInstance().getFlist();

	SequentialWriter writer = SequentialWriter.getInstance();
	
	long gpt = 0L;
	
	long gptUnique = 0L;
	
	public long globalGpt = 0L;
	
	public long globalGptUnique = 0L;
	
	public long totalMatchedSequences = 0L;
	
	public long totalMatches = 0L;
	
	
	//Parallel arrays for buffer, state, pos
	ArrayList<int[]> buffers = new ArrayList<int[]>();
	IntArrayList states = new IntArrayList();
	IntArrayList positions = new IntArrayList();
	
	
	
	
	NaiveIterative(int sigma, XFst dfa, boolean writeOutput, boolean useFlist) {
		this.sigma = sigma;
		this.dfa = dfa;
		yieldArray = new OutputLabel[dfa.oLabelList.size()];
		dfa.states.add(0);
		stateArray = new int[dfa.states.size()];

		dfa.oLabelList.toArray(yieldArray);
		dfa.states.toArray(stateArray);
		
		this.writeOutput = writeOutput;
		this.useFlist = useFlist;
	}
	
	public void scan(String file) throws Exception {
		FileInputStream fstream = new FileInputStream(file);
		DataInputStream in = new DataInputStream(fstream);
		BufferedReader br = new BufferedReader(new InputStreamReader(in));

		//IntArrayList buffer = new IntArrayList();
		
		String line;
		while ((line = br.readLine()) != null) {
			if (!line.isEmpty()) {
				String[] str = line.split("\\s* \\s*");
				sequence = new int[str.length];
				for (int i = 0; i < str.length; ++i) {
					sequence[i] = Integer.parseInt(str[i]);
				}
				
				sid = sid + 1;
				gpt = 0;
				gptUnique = 0;
				//buffer.clear();
				computeMatch();
				globalGpt += gpt;
				globalGptUnique += gptUnique;
				
				if(gpt > 0)
					totalMatchedSequences++;
			}
		}
		br.close();
		
		totalMatches = outputSequences.size();

		// output all frequent sequences
		for (Map.Entry<int[], Long> entry : outputSequences.entrySet()) {
			long value = entry.getValue();
			int support = PrimitiveUtils.getLeft(value);
			if (support >= sigma) {
				noOutputPatterns++;
				if(writeOutput) {
					writer.write(entry.getKey(), support);
				}
			}
		}
	}
	
	
	void computeMatch() {
		
		// Initialize the stack
		buffers.add(new int[0]);
		states.add(dfa.getInitialState());
		positions.add(0);
		
		
		int stackPos = 0;
		while(stackPos < positions.size()) {
			
			int state = states.getInt(stackPos);
			int position = positions.getInt(stackPos);
			int[] buffer = buffers.get(stackPos);
			
			if(dfa.isAccept(state)) {
				if(!(buffer.length == 0)) {
					countSequence(buffer);
					gpt++;
				}
			}
			
			if(position == sequence.length) {
				stackPos++;
				continue;
			}
			
			int inputItem = sequence[position];
			int offset = dfa.getOffset(state, inputItem);
			
			if(offset >= 0) {
				for(; stateArray[offset] !=0 ; offset++) {
					int nextState = stateArray[offset];
					int yieldItem = yieldArray[offset].item;
					int currItem = inputItem;
					
					switch (yieldArray[offset].type) {
					case EPSILON:
						addToStack(buffer, nextState, position + 1);
						break;
						
					case CONSTANT:
						if(!useFlist) {
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = yieldItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						else if(flist[yieldItem] >= sigma){
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = yieldItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						break;
					case SELF:
						if(!useFlist) {
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = inputItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						else if(flist[inputItem] >= sigma) {
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = inputItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						break;
					case SELFGENERALIZE:
						// add parents
						while(hierarchy.hasParent(currItem)) {
							if(currItem == yieldItem) 
								break;
							currItem = hierarchy.getParent(currItem);
							
							if(!useFlist) {
								int[] newBuffer = new int[buffer.length + 1];
								System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
								newBuffer[buffer.length] = currItem;
								
								addToStack(newBuffer, nextState, position + 1);
							}
							else if (flist[currItem] >= sigma) {
								int[] newBuffer = new int[buffer.length + 1];
								System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
								newBuffer[buffer.length] = currItem;
								
								addToStack(newBuffer, nextState, position + 1);
							}
						}
						
						// add item
						if(!useFlist) {
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = inputItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						else if (flist[inputItem] >= sigma) {
							int[] newBuffer = new int[buffer.length + 1];
							System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
							newBuffer[buffer.length] = inputItem;
							
							addToStack(newBuffer, nextState, position + 1);
						}
						break;
						default:
							break;
					}
				}
			}
			stackPos++;
		
		}
		clearStack();
	}
	
	private void countSequence(int[] sequence) {
		Long supSid = outputSequences.get(sequence);
		if (supSid == null) {
			outputSequences.put(sequence, PrimitiveUtils.combine(1, sid));
			gptUnique++;
			return;
		}
		if (PrimitiveUtils.getRight(supSid) != sid) {
			int newCount = PrimitiveUtils.getLeft(supSid) + 1;
			outputSequences.put(sequence, PrimitiveUtils.combine(newCount, sid));
			gptUnique++;
		}
	}

	private void addToStack(int[] buffer, int state, int position) {
		
			buffers.add(buffer);
			states.add(state);
			positions.add(position);
		
	}

	private void clearStack() {
		buffers.clear();
		states.clear();
		positions.clear();
	}

	public int noOutputPatterns() {
		return noOutputPatterns;
	}
	
	
	/** <input> <output> <pattern> <support> <logfile> <0?> <0?>
	 * @throws Exception */
	public static void main(String[] args) throws Exception {
		System.out.println("DESQ-COUNT(I) : " + Arrays.toString(args));
		String input = args[0];
		String output = args[1];
		String pattern = args[2];
		String aPattern = ".* " + pattern.trim();
		int support = Integer.parseInt(args[3]);
		String logfile = args[4];
		boolean writeOutput = (args[5].equals("0")) ? false : true;
		boolean useFlist = (args[6].equals("0")) ? false : true;
		
		String sequenceFile = input.concat("/raw/part-r-00000");
		String dictionary = input.concat("/wc/part-r-00000");
		
		
		/** load dictionary */
		Dictionary dict = Dictionary.getInstance();
		dict.load(dictionary, support);
		
		
		
		
		/** initialize hierarchy */
		int[] itemToParent = dict.getItemToParent();
		SimpleHierarchy.getInstance().initialize(itemToParent);
		
		/** initialize writer */
		if(writeOutput) {
		SequentialWriter writer = SequentialWriter.getInstance();
			writer.setItemIdToItemMap(dict.getItemIdToName());
			writer.setOutputPath(output);
		}	
			
		System.out.println(aPattern);
		
		long tS = System.currentTimeMillis();
		
		/** Generate the automaton */
		PatEx patEx = new PatEx(aPattern);
		Fst cFst = patEx.translateToFst();
		Fst pFst = cFst.prioritize();

		XFst xPFst = pFst.optimizeForExecution();
		
		/** Read the database and mine */
		NaiveIterative nd = new NaiveIterative(support, xPFst, writeOutput, useFlist);
		nd.scan(sequenceFile);
		
		long tE = System.currentTimeMillis();
		long totaltime = (long) ((tE-tS)/1000.0);
		
		double avgGpt = (double) nd.globalGpt/nd.totalMatchedSequences;
		double avgGptUnique = (double) nd.globalGptUnique/nd.totalMatchedSequences;
		
		/** Write stats to log*/
		//method \t pattern \t support \ totaltime
		LogWriter lwriter = LogWriter.getInstance();
		lwriter.setOutputPath(logfile);
		String s = null;
		s = "P-COUNT(I)" 
		+ "\t" + pattern 
		+ "\t" + support 
		+ "\t" + totaltime 
		+ "\t" + nd.noOutputPatterns()
		+ "\t" + nd.totalMatches
		+ "\t" + avgGpt
		+ "\t" + avgGptUnique;
		lwriter.write(s);

	}

	


}
