package mining;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.Map;

import fst.XFst;
import hierarchy.SimpleHierarchy;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.objects.Object2LongOpenCustomHashMap;
import utils.Dictionary;
import utils.IntArrayStrategy;
import utils.PrimitiveUtils;
import writer.SequentialWriter;


/**
 * DesqCount.java
 * @author Kaustubh Beedkar {kbeedkar@uni-mannheim.de}
 */
public abstract class DesqCount {

	protected SimpleHierarchy hierarchy = SimpleHierarchy.getInstance();

	protected Object2LongOpenCustomHashMap<int[]> outputSequences = new Object2LongOpenCustomHashMap<int[]>(
			new IntArrayStrategy());

	protected int sigma;

	protected XFst xfst;

	protected boolean writeOutput = true;
	
	protected boolean useFlist = true;
	
	protected int[] sequence;

	protected int sid = -1;
	
	protected int noOutputPatterns = 0;
	
	protected int[] flist = Dictionary.getInstance().getFlist();

	protected SequentialWriter writer = SequentialWriter.getInstance();
	
	protected long gpt = 0L;
	
	protected long gptUnique = 0L;
	
	protected long globalGpt = 0L;
	
	protected  long globalGptUnique = 0L;
	
	protected  long totalMatchedSequences = 0L;
	
	protected  long totalMatches = 0L;

	
	
	// Methods
	
	public DesqCount(int sigma, XFst dfa, boolean writeOutput, boolean useFlist) {
		this.sigma = sigma;
		this.xfst = dfa;
		this.writeOutput = writeOutput;
		this.useFlist = useFlist;
	}
	
	
	public void scan(String file) throws Exception {
		FileInputStream fstream = new FileInputStream(file);
		DataInputStream in = new DataInputStream(fstream);
		BufferedReader br = new BufferedReader(new InputStreamReader(in));

		IntArrayList buffer = new IntArrayList();
		
		String line;
		while ((line = br.readLine()) != null) {
			if (!line.isEmpty()) {
				String[] str = line.split("\\s* \\s*");
				sequence = new int[str.length];
				for (int i = 0; i < str.length; ++i) {
					sequence[i] = Integer.parseInt(str[i]);
				}
				
				sid = sid + 1;
				gpt = 0;
				gptUnique = 0;
				buffer.clear();
				//computeMatch(buffer, 0, dfa.getInitialState());
				computeMatch();
				globalGpt += gpt;
				globalGptUnique += gptUnique;
				
				if(gpt > 0)
					totalMatchedSequences++;
			}
		}
		br.close();
		
		totalMatches = outputSequences.size();

		// output all frequent sequences
		for (Map.Entry<int[], Long> entry : outputSequences.entrySet()) {
			long value = entry.getValue();
			int support = PrimitiveUtils.getLeft(value);
			if (support >= sigma) {
				noOutputPatterns++;
				if(writeOutput) {
					writer.write(entry.getKey(), support);
				}
			}
		}
	}
	
	protected abstract void computeMatch();
	
	protected void countSequence(int[] sequence) {
		gpt++;
		Long supSid = outputSequences.get(sequence);
		if (supSid == null) {
			outputSequences.put(sequence, PrimitiveUtils.combine(1, sid));
			gptUnique++;
			return;
		}
		if (PrimitiveUtils.getRight(supSid) != sid) {
			int newCount = PrimitiveUtils.getLeft(supSid) + 1;
			outputSequences.put(sequence, PrimitiveUtils.combine(newCount, sid));
			gptUnique++;
		}
		
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}


	public long getGlobalGpt() {
		return globalGpt;
	}


	public long getTotalMatchedSequences() {
		return totalMatchedSequences;
	}


	public long getGlobalGptUnique() {
		return globalGptUnique;
	}


	public int noOutputPatterns() {
		return noOutputPatterns;
	}


	public long getTotalMatches() {
		return totalMatches;
	}

}
