package naive;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Map;

import patex.PatEx;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.objects.Object2LongOpenCustomHashMap;
import utils.Dictionary;
import utils.IntArrayStrategy;
import utils.PrimitiveUtils;
import writer.LogWriter;
import writer.SequentialWriter;
import fst.XFst;
import fst.Fst;
import fst.OutputLabel;
import hierarchy.SimpleHierarchy;

public class NaiveDriver {
	
	//TODO: changed separator in state/output parallel arrays!

	SimpleHierarchy hierarchy = SimpleHierarchy.getInstance();

	Object2LongOpenCustomHashMap<int[]> outputSequences = new Object2LongOpenCustomHashMap<int[]>(
			new IntArrayStrategy());

	int sigma;

	XFst dfa;

	boolean writeOutput = true;
	
	boolean useFlist = true;
	
	// Parallel arrays for yeilds and state
	OutputLabel[] yieldArray;
	int[] stateArray;

	int[] sequence;

	int sid = -1;
	
	int noOutputPatterns = 0;
	
	int[] flist = Dictionary.getInstance().getFlist();

	SequentialWriter writer = SequentialWriter.getInstance();
	
	long gpt = 0L;
	
	long gptUnique = 0L;
	
	public long globalGpt = 0L;
	
	public long globalGptUnique = 0L;
	
	public long totalMatchedSequences = 0L;
	
	public long totalMatches = 0L;

	NaiveDriver(int sigma, XFst dfa, boolean writeOutput, boolean useFlist) {
		this.sigma = sigma;
		this.dfa = dfa;
		yieldArray = new OutputLabel[dfa.oLabelList.size()];
		dfa.states.add(0);
		stateArray = new int[dfa.states.size()];

		dfa.oLabelList.toArray(yieldArray);
		dfa.states.toArray(stateArray);
		
		this.writeOutput = writeOutput;
		this.useFlist = useFlist;
	}

	public void scan(String file) throws Exception {
		FileInputStream fstream = new FileInputStream(file);
		DataInputStream in = new DataInputStream(fstream);
		BufferedReader br = new BufferedReader(new InputStreamReader(in));

		IntArrayList buffer = new IntArrayList();
		
		String line;
		while ((line = br.readLine()) != null) {
			if (!line.isEmpty()) {
				String[] str = line.split("\\s* \\s*");
				sequence = new int[str.length];
				for (int i = 0; i < str.length; ++i) {
					sequence[i] = Integer.parseInt(str[i]);
				}
				
				sid = sid + 1;
				gpt = 0;
				gptUnique = 0;
				buffer.clear();
				computeMatch(buffer, 0, dfa.getInitialState());
				globalGpt += gpt;
				globalGptUnique += gptUnique;
				
				if(gpt > 0)
					totalMatchedSequences++;
			}
		}
		br.close();
		
		totalMatches = outputSequences.size();

		// output all frequent sequences
		for (Map.Entry<int[], Long> entry : outputSequences.entrySet()) {
			long value = entry.getValue();
			int support = PrimitiveUtils.getLeft(value);
			if (support >= sigma) {
				noOutputPatterns++;
				if(writeOutput) {
					writer.write(entry.getKey(), support);
				}
			}
		}
	}

	private void computeMatch(IntArrayList buffer, int pos, int state) {
		if (dfa.isAccept(state)) {
			if(!buffer.isEmpty()) {
				countSequence(buffer.toIntArray());
			}
		}
		if (pos == sequence.length) {
			return;
		}

		int item = sequence[pos];
		int offset = dfa.getOffset(state, item);
		
		if (offset >= 0) {
			for (; stateArray[offset] != 0; offset++) {
				int nextState = stateArray[offset];
				int yieldItem = yieldArray[offset].item;
				int currItem = item;

				switch (yieldArray[offset].type) {
				case EPSILON:
					computeMatch(buffer, pos + 1, nextState);
					break;
				case CONSTANT:
					if(!useFlist) {
						buffer.add(yieldItem);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					else if(flist[yieldItem] >= sigma) {
						buffer.add(yieldItem);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					break;
				case SELF:
					if(!useFlist) {
						buffer.add(item);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					else if(flist[item] >= sigma) {
						buffer.add(item);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					break;
				case SELFGENERALIZE:
					// add parents
					while (hierarchy.hasParent(currItem)) {
						if (currItem == yieldItem)
							break;
						currItem = hierarchy.getParent(currItem);
						
						if(!useFlist) {
							buffer.add(currItem);
							computeMatch(buffer, pos + 1, nextState);
							buffer.remove(buffer.size()-1);
						}
						else if(flist[currItem] >= sigma) {
							buffer.add(currItem);
							computeMatch(buffer, pos + 1, nextState);
							buffer.remove(buffer.size()-1);
						}
					}
					
					//add item
					if(!useFlist) {
						buffer.add(item);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					else if(flist[item] >= sigma) {
						buffer.add(item);
						computeMatch(buffer, pos + 1, nextState);
						buffer.remove(buffer.size()-1);
					}
					break;
				default:
					break;

				}
			}
			
		}
	}

	private void countSequence(int[] sequence) {
		Long supSid = outputSequences.get(sequence);
		if (supSid == null) {
			outputSequences.put(sequence, PrimitiveUtils.combine(1, sid));
			gptUnique++;
			return;
		}
		if (PrimitiveUtils.getRight(supSid) != sid) {
			int newCount = PrimitiveUtils.getLeft(supSid) + 1;
			outputSequences.put(sequence, PrimitiveUtils.combine(newCount, sid));
			gptUnique++;
		}
		gpt++;
	}

	
	/** <input> <output> <pattern> <support> <logfile> <0?> <0?>
	 * @throws Exception */
	public static void main(String[] args) throws Exception {
		System.out.println("P-COUNT : " + Arrays.toString(args));
		String input = args[0];
		String output = args[1];
		String pattern = args[2];
		String aPattern = ".* " + pattern.trim();
		int support = Integer.parseInt(args[3]);
		String logfile = args[4];
		boolean writeOutput = (args[5].equals("0")) ? false : true;
		boolean useFlist = (args[6].equals("0")) ? false : true;
		
		String sequenceFile = input.concat("/raw/part-r-00000");
		String dictionary = input.concat("/wc/part-r-00000");
		
		
		/** load dictionary */
		Dictionary dict = Dictionary.getInstance();
		dict.load(dictionary, support);
		
		
		
		
		/** initialize hierarchy */
		int[] itemToParent = dict.getItemToParent();
		SimpleHierarchy.getInstance().initialize(itemToParent);
		
		/** initialize writer */
		if(writeOutput) {
		SequentialWriter writer = SequentialWriter.getInstance();
			writer.setItemIdToItemMap(dict.getItemIdToName());
			writer.setOutputPath(output);
		}	
			
		System.out.println(aPattern);
		
		long tS = System.currentTimeMillis();
		
		/** Generate the automaton */
		PatEx patEx = new PatEx(aPattern);
		Fst cFst = patEx.translateToFst();
		
		Fst pFst = cFst.prioritize();
		
		XFst xPFst = pFst.optimizeForExecution();
		
		/** Read the database and mine */
		NaiveDriver nd = new NaiveDriver(support, xPFst, writeOutput, useFlist);
		nd.scan(sequenceFile);
		
		long tE = System.currentTimeMillis();
		long totaltime = (long) ((tE-tS)/1000.0);
		
		double avgGpt = (double) nd.globalGpt/nd.totalMatchedSequences;
		double avgGptUnique = (double) nd.globalGptUnique/nd.totalMatchedSequences;
		
		/** Write stats to log*/
		//method \t pattern \t support \ totaltime
		LogWriter lwriter = LogWriter.getInstance();
		lwriter.setOutputPath(logfile);
		String s = null;
		s = "P-COUNT" 
		+ "\t" + pattern 
		+ "\t" + support 
		+ "\t" + totaltime 
		+ "\t" + nd.noOutputPatterns()
		+ "\t" + nd.totalMatches
		+ "\t" + avgGpt
		+ "\t" + avgGptUnique;
		lwriter.write(s);

	}

	private int noOutputPatterns() {
		return noOutputPatterns;
	}

}
