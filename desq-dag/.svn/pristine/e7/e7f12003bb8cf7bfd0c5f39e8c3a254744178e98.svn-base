package driver;

import fst.XFst;
import fst.Fst;
import hierarchy.SimpleHierarchy;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Stopwatch;

import parser.PatEx;
import mining.DesqCount;
import mining.OnePassIterative;
import mining.OnePassRecursive;
import mining.TwoPass;
import utils.Dictionary;
import writer.LogWriter;
import writer.SequentialWriter;

/**
 * DesqCountDriver.java
 * @author Kaustubh Beedkar {kbeedkar@uni-mannheim.de}
 */
public class DesqCountDriver {
	
	// Timers
	public static Stopwatch forwardPassTime = Stopwatch.createUnstarted();
	public static Stopwatch backwardPassTime = Stopwatch.createUnstarted();
	public static Stopwatch outputGenerationTime = Stopwatch.createUnstarted();
	public static Stopwatch fstTime = Stopwatch.createUnstarted();
	public static Stopwatch totalTime = Stopwatch.createUnstarted();
	
	
	/** <input> <output> <pattern> <support> <logfile> <writeOutput:0/1> <useflist: 0/1> <method id: 0/1>
	 * @throws Exception */
	public static void main(String[] args) throws Exception {
		System.out.println("DESQ-COUNT : " + Arrays.toString(args));
		String input = args[0];
		String output = args[1];
		String patternExpression = args[2];
		patternExpression = ".*[" + patternExpression.trim() + "]";
		int support = Integer.parseInt(args[3]);
		String logfile = args[4];
		boolean writeOutput = (args[5].equals("0")) ? false : true;
		boolean useFlist = (args[6].equals("0")) ? false : true;
		int method = Integer.parseInt(args[7]);
		
		
		String sequenceFile = input.concat("/raw/part-r-00000");
		String dictionary = input.concat("/wc/part-r-00000");
		
		
		/** load dictionary */
		Dictionary dict = Dictionary.getInstance();
		dict.load(dictionary, support);
		
		
		/** initialize hierarchy */
		//int[] itemToParent = dict.getItemToParent();
		//SimpleHierarchy.getInstance().initialize(itemToParent);
		SimpleHierarchy.getInstance().initialize(dict.getItemToParent(), dict.getDesc());
		
		
		/** initialize writer */
		if(writeOutput) {
		SequentialWriter writer = SequentialWriter.getInstance();
			writer.setItemIdToItemMap(dict.getItemIdToName());
			writer.setOutputPath(output);
		}	
			
		System.out.println(patternExpression);
		
		
		
		// Generate cFST and pFst
		Fst cFst = PatEx.translateToFst(patternExpression);
		cFst.minimize();
		
		cFst.print("/home/kbeedkar/temp/fst");
		
		// Generate optimized pFst
		XFst xFst = cFst.optimizeForExecution();
		xFst.print("/home/kbeedkar/temp/xfst");
		
		
		// Generate optimized reversepFSt
		XFst rxfst = cFst.optimizeForExecution(false, true);
		rxfst.print("/home/kbeedkar/temp/rxfst");
		
		System.exit(-1);
		
		cFst.prioritize();
		cFst.minimize();
		
		Fst pFst = cFst;
		
		// Generate optimized pFst
		XFst xPFst = pFst.optimizeForExecution();
		
		//xPFst.print("/home/kbeedkar/temp/pfst");
		
		DesqCount dc = null;
		
		//xPFst.print("/home/kbeedkar/temp/xPFST.pdf");
		
		// Two pass
		if(method == 1) {
			// Generate optimized reverse pFst with the same state ids
			pFst.reverse();
			//XFst rXPFst= pFst.optimizeForExecution(false);
			
			//dc = new TwoPass(support, xPFst, writeOutput, useFlist, rXPFst);
		}
		else if(method == 0) {
			dc = new OnePassRecursive(support, xPFst, writeOutput, useFlist);
		}
		else if (method == 2) {
			dc = new OnePassIterative(support, xPFst, writeOutput, useFlist);
		}
		
		//long tS = System.currentTimeMillis();
		
		totalTime.start();
		
		dc.scan(sequenceFile);
		
		totalTime.stop();
		
		//long tE = System.currentTimeMillis();
		//long totaltime = (long) ((tE-tS)/1000.0);
		
		double avgGpt = (double) dc.getGlobalGpt()/dc.getTotalMatchedSequences();
		double avgGptUnique = (double) dc.getGlobalGptUnique()/dc.getTotalMatchedSequences();
		
		/** Write stats to log*/
		//method \t pattern \t support \ totaltime
		LogWriter lwriter = LogWriter.getInstance();
		lwriter.setOutputPath(logfile);
		String s = null;
		s = dc.getClass().getSimpleName()
		+ "\t" + patternExpression 
		+ "\t" + support
		+ "\t" + totalTime.elapsed(TimeUnit.SECONDS)
		+ "\t" + dc.noOutputPatterns()
		+ "\t" + dc.getTotalMatches()
		+ "\t" + String.format("%.2f", avgGpt)
		+ "\t" + String.format("%.2f", avgGptUnique)
		+ "\t" + forwardPassTime.elapsed(TimeUnit.MILLISECONDS)
		+ "\t" + backwardPassTime.elapsed(TimeUnit.MILLISECONDS)
		+ "\t" + outputGenerationTime.elapsed(TimeUnit.MILLISECONDS)
		+ "\t" + fstTime.elapsed(TimeUnit.MILLISECONDS);
		lwriter.write(s);

	}

}
